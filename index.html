<html>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <noscript>Sorry, this app needs JavaScript to run.</noscript>
  <head>
    <title>Feat-Tac-Toe</title>
    <style>
      * {
        font-family: sans-serif;
        font-size: 100%;
        font-weight: lighter;
        margin: 0;
      }
      body {
        background-color: #fffffb;
        height: 100vh;
        display: flex;
        flex-direction: column;
      }
      h1 {
        color: #822000;
        font-family: "Times New Roman", serif;
        font-size: min(2.5em, 8vmin);
        font-variant: small-caps;
        margin: 0 0 0.5em;
      }
      #toggle-info {
        background: transparent;
        border: none;
        cursor: pointer;
        font-size: 0.75em;
        line-height: 1.5em;
        opacity: 0.3;
        position: absolute;
        right: 0.5em;
        top: 0;
      }
      #content {
        display: flex;
        flex-direction: column;
        height: 100%;
        justify-content: center;
        margin: auto;
        padding: 0 2%;
        width: 96%;
      }
      #landing {
        padding: 0 0.5em;
      }
      #container {
        margin: 0 auto;
        max-width: 33em;
        position: relative;
      }
      #grid {
        aspect-ratio: 1 / 1;
        background-color: #fefdee;
        box-shadow: 0px 2px 4px grey;
        column-gap: 0.5em;
        display: grid;
        grid-template-columns: 1fr 1fr 1fr;
        grid-template-rows: 1fr 1fr 1fr;
        position: relative;
        row-gap: 0.5em;
      }
      .challenge {
        align-self: center;
        cursor: pointer;
        margin: auto auto;
        position: relative;
        text-align: center;
      }
      .challenge.false::after {
        color: grey;
        content: "✓";
        font-size: 7em;
        left: 50%;
        opacity: 0%;
        position: absolute;
        text-shadow: 3px 3px 3px black;
        top: 50%;
        transform: translate(-50%, -50%);
        transition: opacity 0.2s;
      }
      .challenge.false:hover::after {
        opacity: 20%;
        transition: opacity 0.2s;
      }
      .challenge.true {
        opacity: 50%;
      }
      .challenge.true::after {
        color: green;
        content: "✓";
        font-size: 7em;
        left: 50%;
        opacity: 100%;
        position: absolute;
        text-shadow: 3px 3px 3px black;
        top: 50%;
        transform: translate(-50%, -50%);
      }
      #info {
        grid-column: 1 / span 3;
        height: 100%;
      }
      p,
      li {
        margin: 0 0 1em;
      }
      .bordered {
        border-radius: 1em;
        border: 0.1em beige solid;
        padding: 1em;
      }
      #menu {
        background: none;
        border: none;
        content: "☰";
        cursor: pointer;
        font-size: 1.5em;
        left: 2%;
        position: absolute;
        top: 2%;
      }
      #overlay {
        background-color: rgba(0, 0, 0, 0.2);
        display: none;
        height: 100%;
        left: 0;
        position: absolute;
        top: 0;
        transition: display 0.2s;
        width: 100%;
        z-index: 10;
      }
      #overlay.visible {
        display: unset;
        transition: display 0.4s;
      }
      #get-started-links {
        column-gap: 1em;
        display: flex;
        flex-direction: row;
        flex-wrap: wrap;
        justify-content: space-around;
        row-gap: 1em;
      }
      #sidebar {
        background-color: #fffffb;
        box-shadow: 0px 1px 4px grey;
        display: flex;
        flex-direction: column;
        justify-content: space-between;
        height: calc(100% - 1em);
        padding: 1em 1em 0;
        position: absolute;
        top: 0;
        transform: translate(-110%, 0);
        transition: transform 0.2s;
        width: 15em;
        z-index: 99;
      }
      #sidebar.visible {
        transform: translate(0%, 0%);
        transition: transform 0.4s;
      }
      #sidebar a {
        display: block;
        margin: 0 0 1em;
      }
      .legal {
        color: #aaaaaa;
        font-size: 0.8em;
        padding: 0 2em 1em;
        text-align: center;
      }
      .legal div {
        margin: 0 0 0.5em;
      }
      a {
        color: #337ab7;
        text-decoration: none;
      }
      hr {
        border: 1px solid;
        color: #eeeeee;
        margin: 0 0 1em;
      }
    </style>

    <script>
      const defaults = {
        "#lucky": {
          featId: "#lucky",
          featName: "Lucky",
          featDescription: {
            p: [
              "You have inexplicable luck that seems to kick in at just the right moment.",
              "You have 3 luck points. Whenever you make an attack roll, an ability check, or a saving throw, you can spend one luck point to roll an additional d20. You can choose to spend one of your luck points after you roll the die, but before the outcome is determined. You choose which of the d20s is used for the attack roll, ability check, or saving throw.",
              "You can also spend one luck point when an attack roll is made against you. Roll a d20, and then choose whether the attack uses the attacker's roll or yours. If more than one creature spends a luck point to influence the outcome of a roll, the points cancel each other out; no additional dice are rolled.",
              "You regain your expended luck points when you finish a long rest.",
            ],
          },
          challenges: [
            { status: false, description: "Critically succeed a Strength check or saving throw" },
            { status: false, description: "Critically hit with an attack" },
            { status: false, description: "Critically succeed a Intellect check or saving throw" },
            { status: false, description: "Critically succeed a Dexterity check or saving throw" },
            { status: false, description: "Critically fail any check or saving throw" },
            { status: false, description: "Critically succeed a Wisdom check or saving throw" },
            { status: false, description: "Critically succeed a Constitution check or saving throw" },
            { status: false, description: "Survive a critical hit" },
            { status: false, description: "Critically succeed a Charisma check or saving throw" },
          ],
        },
        "#great-weapon-master": {
          featId: "#great-weapon-master",
          featName: "Great Weapon Master",
          featDescription: {
            p: [
              "You've learned to put the weight of a weapon to your advantage, letting its momentum empower your strikes. You gain the following benefits:",
            ],
            ul: [
              "On your turn, when you score a critical hit with a melee weapon or reduce a creature to 0 hit points with one, you can make one melee weapon attack as a bonus action.",
              "Before you make a melee attack with a heavy weapon that you are proficient with, you can choose to take a -5 penalty to the attack roll. If the attack hits, you add +10 to the attack's damage.",
            ],
          },
          challenges: [
            { status: false, description: "Critically hit with a 2-handed weapon" },
            { status: false, description: "Defeat an enemy with a greataxe" },
            { status: false, description: "Deal max damage with a 2-handed weapon" },
            { status: false, description: "Defeat an enemy with a greatsword" },
            { status: false, description: "Own at least four 2-handed weapons" },
            { status: false, description: "Defeat an enemy with a maul or greatclub" },
            { status: false, description: "Defeat 2 enemies in a single turn with a 2-handed weapon" },
            { status: false, description: "Defeat an enemy with a halberd" },
            { status: false, description: "Critically succeed a Strength check or saving throw" },
          ],
        },
        "#mobile": {
          featId: "#mobile",
          featName: "Mobile",
          featDescription: {
            p: ["You are exceptionally speedy and agile. You gain the following benefits:"],
            ul: [
              "Your speed increases by 10 feet.",
              "When you use the Dash action, difficult terrain doesn't cost you extra movement on that turn.",
              "When you make a melee attack against a creature, you don't provoke opportunity attacks from that creature for the rest of the turn, whether you hit or not.",
            ],
          },
          challenges: [
            { status: false, description: "Critically succeed a Dexterity check or saving throw" },
            {
              status: false,
              description: "Move through 15 feet of difficult terrain in a single turn",
            },
            { status: false, description: "Successfully jump 10 feet over an obstacle during combat" },
            { status: false, description: "Use your entire movement and successfully attack an enemy" },
            { status: false, description: "Take the Dash action in 5 separate combats" },
            { status: false, description: "Dodge to successfully avoid damage" },
            { status: false, description: "Successfully climb 15 feet during combat" },
            {
              status: false,
              description: "Disengage to avoid opportunity attacks from 3 enemies in a single turn",
            },
            { status: false, description: "Use your entire movement after taking the Dash action" },
          ],
        },
        "#war-caster": {
          featId: "#war-caster",
          featName: "War Caster",
          featDescription: {
            p: [
              "You have practiced casting spells in the midst of combat, learning techniques that grant you the following benefits:",
            ],
            ul: [
              "You have advantage on Constitution saving throws that you make to maintain your concentration on a spell when you take damage.",
              "You can perform the somatic components of spells even when you have weapons or a shield in one or both hands.",
              "When a hostile creature's movement provokes an opportunity attack from you, you can use your reaction to cast a spell at the creature, rather than making an opportunity attack. The spell must have a casting time of 1 action and must target only that creature.",
            ],
          },
          challenges: [
            { status: false, description: "Successfully maintain concentration after getting attacked" },
            { status: false, description: "Kill an enemy with a spell at a distance of 60 feet or more" },
            { status: false, description: "Move at least 15 feet and cast a spell with a range of Touch in a single turn", },
            { status: false, description: "Avoid or otherwise prevent damage by casting a spell with your reaction" },
            { status: false, description: "Critically hit with a spell or cantrip" },
            { status: false, description: "Upcast 3 or more spells at a higher level in a single combat", },
            { status: false, description: "Kill an enemy with a spell at a distance of 30 feet or less" },
            { status: false, description: "Damage 3 or more enemies with a single spell" },
            { status: false, description: "Successfully use your reaction to hit an enemy with an opportunity attack" },
          ],
        },
      };

      function challengeNode(feat, idx) {
        const challenge = feat.challenges[idx];
        const node = document.createElement("div");
        node.id = idx;
        node.className = `challenge ${challenge.status}`;
        node.innerText = challenge.description;
        node.onclick = function (evt) {
          toggleAchievement(feat.featId, idx);
        };
        return node;
      }

      function toggleAchievement(featId, challengeIdx) {
        const state = getState();
        const feat = state[featId];
        feat.challenges[challengeIdx].status = !feat.challenges[challengeIdx].status;
        saveState(state);
        if (checkComplete(feat)) {
          renderInfo(feat);
        } else {
          const challenge = document.getElementById(challengeIdx);
          challenge.replaceWith(challengeNode(feat, challengeIdx));
        }
      }

      function renderChallenges(feat) {
        const children = [];
        for (let i = 0; i < feat.challenges.length; i += 1) {
          const child = challengeNode(feat, i);
          children.push(child);
        }
        document.getElementById("grid").replaceChildren(...children);
      }

      function renderInfo(feat) {
        const featInfo = document.createElement("div");
        featInfo.id = "info";
        const children = [];
        for (const entry of feat.featDescription.p) {
          const p = document.createElement("p");
          p.innerText = entry;
          children.push(p);
        }
        if (feat.featDescription.ul && feat.featDescription.ul.length) {
          const ul = document.createElement("ul");
          for (const entry of feat.featDescription.ul) {
            const li = document.createElement("li");
            li.innerText = entry;
            ul.appendChild(li);
          }
          children.push(ul);
        }
        featInfo.replaceChildren(...children);
        document.getElementById("grid").replaceChildren(featInfo);
      }

      function toggleInfo(feat) {
        if (document.getElementById("grid").childNodes.length > 1) {
          renderInfo(feat);
        } else {
          renderChallenges(feat);
        }
      }

      function checkComplete(feat) {
        // Define winning combinations as indices in the gameState array
        const winCombinations = [
          [0, 1, 2],
          [3, 4, 5],
          [6, 7, 8], // Rows
          [0, 3, 6],
          [1, 4, 7],
          [2, 5, 8], // Columns
          [0, 4, 8],
          [2, 4, 6], // Diagonals
        ];

        const challenges = feat.challenges;
        let complete = false;
        // Check each winning combination
        for (let combination of winCombinations) {
          const [a, b, c] = combination;
          if (challenges[a].status && challenges[b].status && challenges[c].status) {
            return true; // 3-in-a-row found
          }
        }
        return false;
      }

      function populateMenu(state) {
        const landing = document.createElement("a");
        landing.href = "";
        landing.innerText = "How it works";

        const sidebarChildren = [landing, document.createElement("hr")];
        const gettingStartedChildren = [];
        for (const featId of Object.keys(state)) {
          const feat = state[featId];
          const sidebarLink = document.createElement("a");
          const gettingStartedLink = document.createElement("a");
          sidebarLink.href = gettingStartedLink.href = `${featId}`;
          sidebarLink.innerText = gettingStartedLink.innerText = feat.featName;
          sidebarLink.onclick = function () {
            setTimeout(function () {
              renderApp(state, featId);
            }, 10);
            toggleSidebar();
          };
          gettingStartedLink.onclick = function () {
            setTimeout(function () {
              renderApp(state, featId);
            }, 10);
          };
          sidebarChildren.push(sidebarLink);
          gettingStartedChildren.push(gettingStartedLink);
        }

        document.getElementById("nav-links").replaceChildren(...sidebarChildren);

        const reset = document.createElement("a");
        reset.href = "";
        reset.innerText = "Reset";
        reset.onclick = function() {
          saveState(defaults);
        }
        document.getElementById("sidebar").appendChild(reset);

        // a lil nasty but sure whatever my dude
        if (document.getElementById("get-started-links")) {
          document.getElementById("get-started-links").replaceChildren(...gettingStartedChildren);
        }
      }

      function getState() {
        let updateFromDefaults = false;
        const state = {};
        for (const key of Object.keys(defaults)) {
          const feat = localStorage.getItem(key);
          if (!feat) {
            updateFromDefaults = true;
            state[key] = defaults[key];
          } else {
            state[key] = JSON.parse(feat);
          }
        }
        if (updateFromDefaults) {
          saveState(state);
        }
        return state;
      }

      function saveState(state) {
        for (const key of Object.keys(state)) {
          localStorage.setItem(key, JSON.stringify(state[key]));
        }
      }

      function init() {
        const state = getState();
        const hash = window.location.hash;
        if (state[hash]) {
          renderApp(state, hash);
        }

        populateMenu(state);
      }

      function renderApp(state, featId) {
        const feat = state[featId];
        const container = document.getElementById("container");
        const header = document.createElement("h1");
        header.innerText = feat.featName;
        const toggleButton = document.createElement("button");
        toggleButton.id = "toggle-info";
        toggleButton.innerText = "ⓘ";
        toggleButton.onclick = function () {
          const feat = getState()[featId];
          toggleInfo(feat);
        };
        header.append(toggleButton);
        const grid = document.createElement("div");
        grid.id = "grid";
        grid.className = "bordered";
        container.replaceChildren(header, grid);
        if (checkComplete(feat)) {
          renderInfo(feat);
        } else {
          renderChallenges(feat);
        }
      }

      function toggleSidebar() {
        document.getElementById("sidebar").classList.toggle("visible");
        document.getElementById("overlay").classList.toggle("visible");
      }

      window.onload = init;
    </script>
  </head>
  <body>
    <button id="menu" onclick="toggleSidebar()">☰</button>
    <div id="overlay" onclick="toggleSidebar()"></div>
    <div id="sidebar">
      <div id="nav-links"></div>
    </div>
    <div id="content">
      <div id="container">
        <div id="landing">
          <h1>How it works</h1>
          <p>
            “Feat-Tac-Toe” is a homebrew option that allows players to unlock additional feats by completing a set of
            in-game achievements.
          </p>
          <p>
            For each feat, players are given a 3x3 grid of in-game conditions their player-character may satisfy. If a
            player can complete 3-in-a-row, then they permanently unlock that feat for their player character.
          </p>
          <h1>Can I make my own?</h1>
          <p>Absolutely.</p>
          <h1>Let's go!</h1>
          <div id="get-started-links"></div>
        </div>
      </div>
    </div>
    <footer class="legal">
      <div>Dungeons & Dragons content is property of Wizards of the Coast LLC.</div>
      <div>Original content &copy;2023, Patrick Stewart</div>
    </footer>
  </body>
</html>
